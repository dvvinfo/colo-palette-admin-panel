# Счетчик уведомлений - интеграция с бэкендом

## Обзор

Счетчик уведомлений полностью интегрирован с бэкендом API и обновляется по событиям для максимальной эффективности.

## Архитектура

### API Endpoint
```
GET /api/notification/count?status=unread
```

**Ответ:**
```json
{
  "data": 5
}
```

### Store логика

Счетчик использует гибридный подход:

1. **Серверный счетчик** (приоритет) - получается через API
2. **Локальный счетчик** (fallback) - вычисляется из загруженных уведомлений

```typescript
const unreadCount = computed(() => {
  if (serverUnreadCount.value !== null) {
    return serverUnreadCount.value  // Используем серверное значение
  }
  return notifications.value.filter(n => !n.is_read).length  // Локальный подсчет
})
```

## Обновление по событиям

### Инициализация
При загрузке приложения (`AdminLayout.vue`):
```typescript
onMounted(() => {
  notificationsStore.fetchUnreadCount()
})
```

### Обновление при действиях пользователя
Счетчик обновляется только при реальных событиях:
- При открытии dropdown уведомлений
- После изменения статуса уведомления
- После удаления уведомления
- После массовых операций (отметить все как прочитанные, удалить все)
- При создании нового уведомления

### Преимущества событийного подхода
- ✅ **Эффективность** - нет лишних запросов к серверу
- ✅ **Актуальность** - обновления происходят сразу при изменениях
- ✅ **Производительность** - снижена нагрузка на сервер и клиент
- ✅ **Точность** - данные всегда синхронизированы с действиями пользователя

## Синхронизация

### Оптимистичные обновления
При действиях пользователя счетчик обновляется локально для мгновенного отклика:

```typescript
// При отметке как прочитанное
if (wasUnread && notification.is_read) {
  serverUnreadCount.value = Math.max(0, serverUnreadCount.value - 1)
}

// При отметке как непрочитанное  
if (!wasUnread && !notification.is_read) {
  serverUnreadCount.value += 1
}
```

### Точность данных
Обновления происходят при каждом действии пользователя, что гарантирует актуальность данных без избыточных запросов.

## Визуальные индикаторы

### Счетчик
```vue
<span v-if="notificationsStore.unreadCount > 0">
  {{ notificationsStore.unreadCount > 99 ? '99+' : notificationsStore.unreadCount }}
</span>
```

### Индикатор загрузки
```vue
<div v-if="notificationsStore.countLoading" 
     class="animate-spin border-2 border-primary">
</div>
```

## Обработка ошибок

При ошибках запроса к серверу:
1. Счетчик автоматически переключается на локальный подсчет
2. Логируется ошибка в консоль
3. При следующем действии пользователя происходит повторная попытка синхронизации

## Производительность

### Оптимизации:
- ✅ **Событийное обновление** - запросы только при необходимости
- ✅ **Кэширование серверного значения** - избегаем дублирующих запросов
- ✅ **Локальные обновления** - мгновенный отклик на действия
- ✅ **Оптимистичная синхронизация** - обновление локального состояния до ответа сервера

### Сетевые запросы:
- **Начальная загрузка**: 1 запрос при старте приложения
- **При действиях пользователя**: 1 запрос при необходимости синхронизации
- **При открытии dropdown**: 1 запрос для актуализации (если нужно)

## Тестирование

Для тестирования работы счетчика:

1. **Создайте уведомление** через админ-панель
2. **Проверьте обновление счетчика** (должно произойти автоматически)
3. **Отметьте уведомление как прочитанное** - счетчик должен уменьшиться мгновенно
4. **Обновите страницу** - счетчик должен загрузиться с сервера
5. **Откройте dropdown** - счетчик должен актуализироваться

## API интеграция

Полный список методов для работы со счетчиком:

```typescript
// Загрузка счетчика (при инициализации и по требованию)
await notificationsStore.fetchUnreadCount()

// Получение текущего значения
const count = notificationsStore.unreadCount

// Проверка статуса загрузки
const isLoading = notificationsStore.countLoading
```

## Сценарии обновления

### 1. Загрузка приложения
```typescript
// AdminLayout.vue onMounted
notificationsStore.fetchUnreadCount()
```

### 2. Открытие dropdown уведомлений
```typescript
// NotificationsDropdown.vue toggleNotifications
if (notifications.length === 0) {
  fetchNotifications() // загружает список + счетчик
} else {
  fetchUnreadCount() // только счетчик
}
```

### 3. Изменение статуса уведомления
```typescript
// Оптимистичное обновление + API вызов
serverUnreadCount.value += delta
await api.toggleStatus(id)
```

### 4. Массовые операции
```typescript
// Оптимистичное обнуление + API вызов
serverUnreadCount.value = 0
await api.markAllAsRead()
```

## Будущие улучшения

- **WebSocket уведомления** для real-time обновлений от сервера
- **Push уведомления** для получения новых уведомлений
- **Service Worker** для обновлений в фоне
- **Локальное кэширование** для offline режима 